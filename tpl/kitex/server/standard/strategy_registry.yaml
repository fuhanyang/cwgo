path: biz/strategy/registry.go
update_behavior:
  type: skip
body: |-
  package strategy
  
  import (
    "fmt"
    "sort"
    "sync"
  )
  
  // Registry stores named handlers and the currently active handler name.
  // It is safe for concurrent reads after initialization.
  type Registry[H any] struct {
    mu       sync.RWMutex
    handlers map[string]H
    active   string
  }
  
  func NewRegistry[H any]() *Registry[H] {
    return &Registry[H]{handlers: make(map[string]H)}
  }
  
  // Register registers a handler under a name.
  // It returns an error if name is empty or already registered.
  func (r *Registry[H]) Register(name string, h H) error {
    if name == "" {
      return fmt.Errorf("strategy: empty name")
    }
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.handlers == nil {
      r.handlers = make(map[string]H)
    }
    if _, exists := r.handlers[name]; exists {
      return fmt.Errorf("strategy: %q already registered", name)
    }
    r.handlers[name] = h
    return nil
  }
  
  // SetActive selects an already-registered strategy name as active.
  func (r *Registry[H]) SetActive(name string) error {
    if name == "" {
      return fmt.Errorf("strategy: empty active name")
    }
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.handlers == nil {
      return fmt.Errorf("strategy: %q not found (no strategies registered)", name)
    }
    if _, ok := r.handlers[name]; !ok {
      return fmt.Errorf("strategy: %q not found (available: %v)", name, r.namesLocked())
    }
    r.active = name
    return nil
  }
  
  // Active returns the active handler. ok is false if no active strategy is set
  // or the active name has no corresponding handler.
  func (r *Registry[H]) Active() (h H, ok bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    if r.handlers == nil || r.active == "" {
      return h, false
    }
    h, ok = r.handlers[r.active]
    return h, ok
  }
  
  // Get returns a handler by name.
  func (r *Registry[H]) Get(name string) (h H, ok bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    if r.handlers == nil || name == "" {
      return h, false
    }
    h, ok = r.handlers[name]
    return h, ok
  }
  
  // Names returns sorted registered strategy names.
  func (r *Registry[H]) Names() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()
    return r.namesLocked()
  }
  
  func (r *Registry[H]) namesLocked() []string {
    if len(r.handlers) == 0 {
      return nil
    }
    names := make([]string, 0, len(r.handlers))
    for n := range r.handlers {
      names = append(names, n)
    }
    sort.Strings(names)
    return names
  }
