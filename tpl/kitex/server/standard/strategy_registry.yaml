path: biz/strategy/registry.go
update_behavior:
  type: cover
body: |-
  package strategy
  
  import (
    "fmt"
    "sort"
    "sync"
  )
  
  // Registry stores named handlers and the currently active handler name.
  // It is safe for concurrent reads after initialization.
  type Registry[H any] struct {
    mu       sync.RWMutex
    handlers map[string]H
    active   string
  }
  
  func NewRegistry[H any]() *Registry[H] {
    return &Registry[H]{handlers: make(map[string]H)}
  }
  
  // Register registers a handler under a name.
  // It returns an error if name is empty or already registered.
  func (r *Registry[H]) Register(name string, h H) error {
    if name == "" {
      return fmt.Errorf("strategy: empty name")
    }
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.handlers == nil {
      r.handlers = make(map[string]H)
    }
    if _, exists := r.handlers[name]; exists {
      return fmt.Errorf("strategy: %q already registered", name)
    }
    r.handlers[name] = h
    return nil
  }
  
  // SetActive selects an already-registered strategy name as active.
  func (r *Registry[H]) SetActive(name string) error {
    if name == "" {
      return fmt.Errorf("strategy: empty active name")
    }
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.handlers == nil {
      return fmt.Errorf("strategy: %q not found (no strategies registered)", name)
    }
    if _, ok := r.handlers[name]; !ok {
      return fmt.Errorf("strategy: %q not found (available: %v)", name, r.namesLocked())
    }
    r.active = name
    return nil
  }
  
  // Active returns the active handler. ok is false if no active strategy is set
  // or the active name has no corresponding handler.
  func (r *Registry[H]) Active() (h H, ok bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    if r.handlers == nil || r.active == "" {
      return h, false
    }
    h, ok = r.handlers[r.active]
    return h, ok
  }
  
  // Get returns a handler by name.
  func (r *Registry[H]) Get(name string) (h H, ok bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    if r.handlers == nil || name == "" {
      return h, false
    }
    h, ok = r.handlers[name]
    return h, ok
  }
  
  // Names returns sorted registered strategy names.
  func (r *Registry[H]) Names() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()
    return r.namesLocked()
  }
  
  func (r *Registry[H]) namesLocked() []string {
    if len(r.handlers) == 0 {
      return nil
    }
    names := make([]string, 0, len(r.handlers))
    for n := range r.handlers {
      names = append(names, n)
    }
    sort.Strings(names)
    return names
  }

  // Processor is an atomic, named step in a strategy pipeline.
  // It is recommended to keep processors stateless and reusable.
  type Processor[S any] interface {
    Name() string
    Process(s *S) error
  }

  // ProcessorFunc adapts a function into a Processor.
  type ProcessorFunc[S any] struct {
    name string
    fn   func(*S) error
  }

  func (p ProcessorFunc[S]) Name() string { return p.name }

  func (p ProcessorFunc[S]) Process(s *S) error { return p.fn(s) }

  func NewProcessorFunc[S any](name string, fn func(*S) error) Processor[S] {
    return ProcessorFunc[S]{name: name, fn: fn}
  }

  // ProcessorRegistry stores named processors.
  type ProcessorRegistry[S any] struct {
    r *Registry[Processor[S]]
  }

  func NewProcessorRegistry[S any]() *ProcessorRegistry[S] {
    return &ProcessorRegistry[S]{r: NewRegistry[Processor[S]]()}
  }

  func (pr *ProcessorRegistry[S]) Register(p Processor[S]) error {
    if p == nil {
      return fmt.Errorf("strategy: nil processor")
    }
    name := p.Name()
    if name == "" {
      return fmt.Errorf("strategy: empty processor name")
    }
    return pr.r.Register(name, p)
  }

  func (pr *ProcessorRegistry[S]) RegisterFunc(name string, fn func(*S) error) error {
    return pr.r.Register(name, NewProcessorFunc[S](name, fn))
  }

  func (pr *ProcessorRegistry[S]) Get(name string) (p Processor[S], ok bool) {
    return pr.r.Get(name)
  }

  func (pr *ProcessorRegistry[S]) Names() []string { return pr.r.Names() }
