path: biz/strategy/registry.go
update_behavior:
  type: cover
body: |-
  package strategy

  import (
    "fmt"
    "sort"

    "{{.Module}}/biz/processor"
  )

  // Registry stores named handlers and the currently active handler name.
  // It is NOT thread-safe for writes. All registrations must happen before
  // the service starts handling requests (e.g. in init() or main()).
  // Reads (Get/Active) are concurrent-safe assuming no writes happen after initialization.
  type Registry[H any] struct {
    handlers map[string]H
  }

  func NewRegistry[H any]() *Registry[H] {
    return &Registry[H]{handlers: make(map[string]H)}
  }

  // Register registers a handler under a name.
  // It returns an error if name is empty or already registered.
  // NOTE: Call this ONLY during initialization, before starting the server.
  func (r *Registry[H]) Register(name string, h H) error {
    if name == "" {
      return fmt.Errorf("strategy: empty name")
    }
    if r.handlers == nil {
      r.handlers = make(map[string]H)
    }
    if _, exists := r.handlers[name]; exists {
      return fmt.Errorf("strategy: %q already registered", name)
    }
    r.handlers[name] = h
    return nil
  }

  // Get returns a handler by name.
  func (r *Registry[H]) Get(name string) (h H, ok bool) {
    if r.handlers == nil || name == "" {
      return h, false
    }
    h, ok = r.handlers[name]
    return h, ok
  }

  // Names returns sorted registered strategy names.
  func (r *Registry[H]) Names() []string {
    return r.namesLocked()
  }

  func (r *Registry[H]) namesLocked() []string {
    if len(r.handlers) == 0 {
      return nil
    }
    names := make([]string, 0, len(r.handlers))
    for n := range r.handlers {
      names = append(names, n)
    }
    sort.Strings(names)
    return names
  }

  // ProcessorRegistry stores named processors.
  type ProcessorRegistry[S any] struct {
    r *Registry[processor.Processor[S]]
  }

  func NewProcessorRegistry[S any]() *ProcessorRegistry[S] {
    return &ProcessorRegistry[S]{r: NewRegistry[processor.Processor[S]]()}
  }

  func (pr *ProcessorRegistry[S]) Register(p processor.Processor[S]) error {
    if p == nil {
      return fmt.Errorf("strategy: nil processor")
    }
    name := p.Name()
    if name == "" {
      return fmt.Errorf("strategy: empty processor name")
    }
    return pr.r.Register(name, p)
  }

  func (pr *ProcessorRegistry[S]) RegisterFunc(name string, fn func(*S) error) error {
    return pr.r.Register(name, processor.NewProcessorFunc[S](name, fn))
  }

  func (pr *ProcessorRegistry[S]) Get(name string) (p processor.Processor[S], ok bool) {
    return pr.r.Get(name)
  }

  func (pr *ProcessorRegistry[S]) Names() []string { return pr.r.Names() }
