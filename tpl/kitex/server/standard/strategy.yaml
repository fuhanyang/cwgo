path: biz/strategy/{{SnakeString .ServiceName}}_strategy/{{ SnakeString (index .Methods 0).Name }}.go
loop_method: true
update_behavior:
  type: skip
body: |-
  package {{SnakeString .ServiceName}}_strategy

  import (
    "context"
    "fmt"

    "{{.Module}}/biz/processor"
    "{{.Module}}/biz/processor/common"
    "{{.Module}}/biz/service/{{SnakeString .ServiceName}}"
    "{{.Module}}/biz/strategy"
  	{{- range $path, $aliases := ( FilterImports .Imports .Methods )}}
  		{{- if not $aliases }}
  			"{{$path}}"
      {{- else if or (eq $path "github.com/cloudwego/kitex/client") (eq $path "github.com/cloudwego/kitex/pkg/serviceinfo")}}
  		{{- else}}
  			{{- range $alias, $is := $aliases}}
  				{{$alias}} "{{$path}}"
  			{{- end}}
  		{{- end}}
  	{{- end}}
  )

  {{range .Methods}}
  // Init{{.Name}}Strategies initializes strategies for {{.Name}}.
  func Init{{.Name}}Strategies(cfg strategy.ServiceStrategyConfig) error {
    reg := strategy.NewProcessorRegistry[{{SnakeString $.ServiceName}}.{{.Name}}State]()

    // 1) Register service-specific processors here.
    // Example:
    // if err := somepkg.InstallProcessors(reg); err != nil { ... }

    // 2) Register generic processors (cross-cutting)
    if err := reg.Register(processor.WrapGenericProcessor[{{SnakeString $.ServiceName}}.{{.Name}}State]("log", common.LogProcessor)); err != nil {
      return fmt.Errorf("register generic processor log: %w", err)
    }

    // 3) Build strategies from config (strategy -> ordered processors).
    {{- if .Void}}
    return BuildAndRegisterVoidStrategies(
      cfg,
      "{{SnakeString .Name}}",
      reg,
      {{SnakeString $.ServiceName}}.{{.Name}}Strategies,
      func(ctx context.Context, req {{(index .Args 0).Type}}) *{{SnakeString $.ServiceName}}.{{.Name}}State {
        return &{{SnakeString $.ServiceName}}.{{.Name}}State{
          Ctx:  ctx,
          Req:  req,
          Vars: map[string]any{},
        }
      },
      func(f func(context.Context, {{(index .Args 0).Type}}) error) {{SnakeString $.ServiceName}}.{{.Name}}Handler {
        return {{SnakeString $.ServiceName}}.{{.Name}}Handler(f)
      },
    )
    {{- else}}
    return BuildAndRegisterStrategies(
      cfg,
      "{{SnakeString .Name}}",
      reg,
      {{SnakeString $.ServiceName}}.{{.Name}}Strategies,
      func(ctx context.Context, req {{(index .Args 0).Type}}) *{{SnakeString $.ServiceName}}.{{.Name}}State {
        return &{{SnakeString $.ServiceName}}.{{.Name}}State{
          Ctx:  ctx,
          Req:  req,
          Vars: map[string]any{},
        }
      },
      func(s *{{SnakeString $.ServiceName}}.{{.Name}}State) {{.Resp.Type}} { return s.Resp },
      func(f func(context.Context, {{(index .Args 0).Type}}) ({{.Resp.Type}}, error)) {{SnakeString $.ServiceName}}.{{.Name}}Handler {
        return {{SnakeString $.ServiceName}}.{{.Name}}Handler(f)
      },
    )
    {{- end}}
  }
  {{end}}

