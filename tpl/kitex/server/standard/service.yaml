path: biz/service/{{SnakeString .ServiceName}}/{{ SnakeString (index .Methods 0).Name }}.go
loop_method: true
update_behavior:
  type: skip
body: |-
  package {{SnakeString .ServiceName}}

  import (
  	"context"
    "fmt"

    "{{.Module}}/biz/strategy"

  	{{- range $path, $aliases := ( FilterImports .Imports .Methods )}}
  		{{- if not $aliases }}
  			"{{$path}}"
        {{- else if or (eq $path "github.com/cloudwego/kitex/client") (eq $path "github.com/cloudwego/kitex/pkg/serviceinfo")}}
  		{{- else}}
  			{{- range $alias, $is := $aliases}}
  				{{$alias}} "{{$path}}"
  			{{- end}}
  		{{- end}}
  	{{- end}}
  )

  {{range .Methods}}
  // {{.Name}}Handler defines the function signature for {{.Name}} processor
  type {{.Name}}Handler func(ctx context.Context, {{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) ({{if not .Void}}{{ .Resp.Type }}, {{end}}error)

  // {{.Name}}State carries request-scoped data across processors.
  type {{.Name}}State struct {
    Ctx  context.Context
    {{- range .Args}}
    {{.Name}} {{.Type}}
    {{- end}}
    {{- if not .Void}}
    Resp {{.Resp.Type}}
    {{- end}}
    Vars map[string]any
  }

  // {{.Name}}Processor is an atomic step in a strategy pipeline.
  type {{.Name}}Processor func(s *{{.Name}}State) error

  // {{.Name}}Processors stores named processors for {{.Name}}.
  var {{.Name}}Processors = strategy.NewRegistry[{{.Name}}Processor]()

  // {{.Name}}Strategies stores the execution strategies for {{.Name}}
  var {{.Name}}Strategies = strategy.NewRegistry[{{.Name}}Handler]()

  // Choose{{.Name}}Strategy selects a strategy name for {{.Name}} per request.
  // Returning empty string means using "default".
  var Choose{{.Name}}Strategy = func(ctx context.Context, {{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) string {
    return "default"
  }

  type {{.Name}}Service struct {
    ctx context.Context
  }

  {{- if or .ClientStreaming .ServerStreaming}}

  // New{{.Name}}Service new {{.Name}}Service
  func New{{.Name}}Service(ctx context.Context) *{{.Name}}Service {
    return &{{.Name}}Service{ctx: ctx}
  }

  func (s *{{.Name}}Service) Run({{if not .ClientStreaming}}{{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}{{end}}stream {{.PkgRefName}}.{{.ServiceName}}_{{.RawName}}Server) (err error) {
    // Streaming not supported in strategy mode yet
    err = fmt.Errorf("streaming not supported in strategy mode yet")
    return
  }
  {{- else}}
  {{- if .Void}}
  {{- if .Oneway}}
  {{- end}}

  // New{{.Name}}Service new {{.Name}}Service
  func New{{.Name}}Service(ctx context.Context) *{{.Name}}Service {
    return &{{.Name}}Service{ctx: ctx}
  }

  // Run calls the registered strategy for {{.Name}}
  func (s *{{.Name}}Service) Run({{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) error {
    name := Choose{{.Name}}Strategy(s.ctx, {{range .Args}}{{LowerFirst .Name}}, {{end}})
    if name == "" {
      name = "default"
    }
    handler, ok := {{.Name}}Strategies.Get(name)
    if !ok {
      return fmt.Errorf("strategy %q not found for {{.Name}} (available: %v)", name, {{.Name}}Strategies.Names())
    }
    return handler(s.ctx, {{range .Args}}{{LowerFirst .Name}}, {{end}})
  }
  {{else}}

  // New{{.Name}}Service new {{.Name}}Service
  func New{{.Name}}Service(ctx context.Context) *{{.Name}}Service {
    return &{{.Name}}Service{ctx: ctx}
  }

  // Run calls the registered strategy for {{.Name}}
  func (s *{{.Name}}Service) Run({{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) (resp {{.Resp.Type}}, err error) {
    name := Choose{{.Name}}Strategy(s.ctx, {{range .Args}}{{LowerFirst .Name}}, {{end}})
    if name == "" {
      name = "default"
    }
    handler, ok := {{.Name}}Strategies.Get(name)
    if !ok {
      err = fmt.Errorf("strategy %q not found for {{.Name}} (available: %v)", name, {{.Name}}Strategies.Names())
      return
    }
    return handler(s.ctx, {{range .Args}}{{LowerFirst .Name}}, {{end}})
  }
  {{end}}
  {{end}}
  {{end}}
