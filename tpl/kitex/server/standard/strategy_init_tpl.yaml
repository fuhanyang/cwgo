path: strategy_init.go
update_behavior:
  type: cover
body: |-
  package main

  import (
    "context"
    "fmt"

    "{{.Module}}/biz/service/{{SnakeString .ServiceName}}"
    "{{.Module}}/biz/strategy/{{SnakeString .ServiceName}}_strategy"
    "{{.Module}}/biz/processor"
  	{{- range $path, $aliases := ( FilterImports .Imports .Methods )}}
  		{{- if not $aliases }}
  			"{{$path}}"
        {{- else if or (eq $path "github.com/cloudwego/kitex/client") (eq $path "github.com/cloudwego/kitex/pkg/serviceinfo")}}
  		{{- else}}
  			{{- range $alias, $is := $aliases}}
  				{{$alias}} "{{$path}}"
  			{{- end}}
  		{{- end}}
  	{{- end}}
  )

  func initStrategies() error {
    // 1) Explicitly register all processors (user-defined).
    {{ range .Methods }}
    if err := {{SnakeString $.ServiceName}}_strategy.Register{{.Name}}Processors(); err != nil {
      return fmt.Errorf("register processors for {{.Name}}: %w", err)
    }
    {{ end }}

    // 2) Build strategies from per-service config (strategy -> ordered processors).
    cfg, found, err := {{SnakeString $.ServiceName}}_strategy.LoadStrategyConfig()
    if err != nil {
      return fmt.Errorf("load {{SnakeString $.ServiceName}} strategy config: %w", err)
    }
    _ = found // found=false means no strategy file; will fallback to default.
    {{ range .Methods }}
    {
      key := "{{SnakeString .Name}}"
      strategies := cfg[key]
      if len(strategies) == 0 {
        strategies = map[string][]string{"default": []string{}}
      }

      for strategyName, pipeline := range strategies {
        // Copy to avoid capturing the loop variable.
        steps := append([]string(nil), pipeline...)

        // Validate pipeline contract
        var procs []processor.Processor[{{SnakeString $.ServiceName}}.{{.Name}}State]
        for _, name := range steps {
            p, ok := {{SnakeString $.ServiceName}}.{{.Name}}Processors.Get(name)
            if !ok {
                return fmt.Errorf("{{.Name}} strategy %q: processor %q not found", strategyName, name)
            }
            procs = append(procs, p)
        }
        // ValidatePipeline ensures that every processor's required inputs are met by previous outputs.
        if err := processor.ValidatePipeline(procs, []processor.DataField{
            "Ctx",
            {{- range .Args}}
            "{{.Name}}",
            {{- end}}
        }); err != nil {
            return fmt.Errorf("validate {{.Name}} strategy %q: %w", strategyName, err)
        }

        {{ if .Void }}
        if err := {{SnakeString $.ServiceName}}.{{.Name}}Strategies.Register(strategyName, func(ctx context.Context, {{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) error {
          st := &{{SnakeString $.ServiceName}}.{{.Name}}State{
            Ctx: ctx,
            {{- range .Args}}
            {{.Name}}: {{LowerFirst .Name}},
            {{- end}}
            Vars: map[string]any{},
          }
          for _, procName := range steps {
            proc, ok := {{SnakeString $.ServiceName}}.{{.Name}}Processors.Get(procName)
            if !ok {
              return fmt.Errorf("{{.Name}} strategy %q: processor %q not found (available: %v)", strategyName, procName, {{SnakeString $.ServiceName}}.{{.Name}}Processors.Names())
            }
            if err := proc.Process(st); err != nil {
              return fmt.Errorf("{{.Name}} strategy %q: processor %q failed: %w", strategyName, procName, err)
            }
          }
          return nil
        }); err != nil {
          return fmt.Errorf("register {{.Name}} strategy %q: %w", strategyName, err)
        }
        {{ else }}
        if err := {{SnakeString $.ServiceName}}.{{.Name}}Strategies.Register(strategyName, func(ctx context.Context, {{range .Args}}{{LowerFirst .Name}} {{.Type}}, {{end}}) (resp {{.Resp.Type}}, err error) {
          st := &{{SnakeString $.ServiceName}}.{{.Name}}State{
            Ctx: ctx,
            {{- range .Args}}
            {{.Name}}: {{LowerFirst .Name}},
            {{- end}}
            Vars: map[string]any{},
          }
          for _, procName := range steps {
            proc, ok := {{SnakeString $.ServiceName}}.{{.Name}}Processors.Get(procName)
            if !ok {
              err = fmt.Errorf("{{.Name}} strategy %q: processor %q not found (available: %v)", strategyName, procName, {{SnakeString $.ServiceName}}.{{.Name}}Processors.Names())
              return
            }
            if err = proc.Process(st); err != nil {
              err = fmt.Errorf("{{.Name}} strategy %q: processor %q failed: %w", strategyName, procName, err)
              return
            }
          }
          resp = st.Resp
          return
        }); err != nil {
          return fmt.Errorf("register {{.Name}} strategy %q: %w", strategyName, err)
        }
        {{ end }}
      }
    }
    {{ end }}
    return nil
  }
