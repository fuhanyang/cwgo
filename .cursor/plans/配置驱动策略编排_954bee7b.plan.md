---
name: 配置驱动策略编排
overview: 把策略定义从“代码注册 handler”升级为“conf 定义 pipeline（strategy->processors）”，processor 由用户代码注册；service 在每次请求中动态选择策略名并执行对应 pipeline。
todos:
  - id: registry-get
    content: 扩展 `strategy_registry.yaml`：为 Registry 增加 Get(name) API（必要时保留 Active 以兼容）
    status: completed
  - id: service-state-and-chooser
    content: 更新 `service.yaml`：生成 MethodState/Processor/Processors registry；Run() 使用 Choose{{Method}}Strategy + Strategies.Get() 执行
    status: completed
  - id: conf-nested-strategy
    content: 更新 `conf_tpl.yaml` 与 env conf.yaml：Strategy 改为 method->strategy->[]processor 的嵌套结构
    status: completed
  - id: init-build-strategies
    content: 更新 `strategy_init_tpl.yaml`：从 conf 编译 pipeline 为 handler 并注册到 Strategies（不再 SetActive）
    status: completed
  - id: deprecate-code-strategy-template
    content: 调整 `strategy.yaml` 角色：不再负责注册 handler（避免与 conf 驱动重复），改为示例或 processor 注册引导
    status: completed
---

## 目标

- **策略内容来自配置**：`conf.yaml` 定义每个 RPC 方法下的多个策略（strategyName）以及线性 processor 列表。
- **processor 来自用户代码**：用户实现 processor（原子步骤）并在启动时显式注册到 ProcessorRegistry。
- **service 动态选策略（你选的 B）**：每次请求由用户逻辑选择 strategyName（可基于请求字段/ctx），然后执行对应策略；若返回空则 fallback 到 `default`。

## 设计（生成项目内）

### 1) Method State + Processor 类型（State mutation）

- 在 `biz/service/<service>/<method>.go`（由 `tpl/kitex/server/standard/service.yaml` 生成）为每个方法生成：
  - `type {{.Name}}State struct { Ctx context.Context; ...Args...; Resp {{.Resp.Type}}; Vars map[string]any }`
  - `type {{.Name}}Processor func(s *{{.Name}}State) error`
  - `var {{.Name}}Processors = strategy.NewRegistry[{{.Name}}Processor]()`（仅用于 name->processor 查找）
  - `var {{.Name}}Strategies = strategy.NewRegistry[{{.Name}}Handler]()`（name->compiled handler）
  - `var Choose{{.Name}}Strategy = func(ctx context.Context, ...args) string { return "default" }`
  - `Run()` 改为：
    - `name := Choose{{.Name}}Strategy(...)`，空则 `default`
    - `h, ok := {{.Name}}Strategies.Get(name)`，无则报错并列出可用策略
    - 调用 `h(ctx, args...)`

### 2) Registry 增强（支持 Get，不再依赖 Active）

- 扩展 `biz/strategy/registry.go`（由 `tpl/kitex/server/standard/strategy_registry.yaml` 生成）：
  - 增加 `Get(name) (H, bool)`
  - `Active/SetActive` 可以保留（向后兼容），但 service 模板改为不使用 Active。

### 3) 配置格式（per-method strategies）

- 更新 `conf/conf.go`（模板 `tpl/kitex/server/standard/conf_tpl.yaml`）：
  - `Strategy map[string]map[string][]string \`yaml:"strategy"\``
    - 第 1 层 key：methodKey（建议 `{{SnakeString .Name}}`）
    - 第 2 层 key：strategyName（如 `default`/`canary`）
    - value：processorName 列表（线性 pipeline）
- 更新 `conf/*/conf.yaml` 模板：为每个方法生成一个 `default` pipeline（默认空或示例 1-2 步）。

### 4) 启动时：从 conf 编译并注册策略（register from conf）

- 重写 `strategy_init.go`（模板 `tpl/kitex/server/standard/strategy_init_tpl.yaml`）：
  - `func initStrategies() error`：
    - 读取 `cfg := conf.GetConf()`
    - 对每个方法：
      - 遍历 `cfg.Strategy[methodKey]` 的每个 strategyName/pipeline
      - `compiled := func(ctx,...args) (...) { state := &{{.Name}}State{Ctx: ctx, Args..., Vars: map[string]any{}}; for _, pName := range pipeline { p, ok := {{.Name}}Processors.Get(pName); if !ok { return err } ; if err := p(state); err != nil { return err } } ; return state.Resp, nil }`
      - `{{.Name}}Strategies.Register(strategyName, compiled)`
  - **不再设置 active**（因为每请求动态选择）。

### 5) 用户扩展点（你要的灵活度）

- 用户通过两件事自定义行为：
  - 注册 processor：`{{.Name}}Processors.Register("check_permission", CheckPermission)` 等
  - 实现动态策略选择：覆盖/赋值 `service.Choose{{.Name}}Strategy = func(ctx,...args) string { ... }`

## 需要修改/新增的模板文件

- [`tpl/kitex/server/standard/strategy_registry.yaml`](tpl/kitex/server/standard/strategy_registry.yaml)：加 `Get()`（可保留 Active API）。
- [`tpl/kitex/server/standard/service.yaml`](tpl/kitex/server/standard/service.yaml)：
  - 增加 `{{.Name}}State`/`{{.Name}}Processor`/`{{.Name}}Processors`
  - `Run()` 改为调用 `Choose{{.Name}}Strategy` + `Strategies.Get()`。
- [`tpl/kitex/server/standard/conf_tpl.yaml`](tpl/kitex/server/standard/conf_tpl.yaml)：Strategy 字段改成嵌套 map。
- [`tpl/kitex/server/standard/conf_dev_tpl.yaml`](tpl/kitex/server/standard/conf_dev_tpl.yaml)、`conf_online_tpl.yaml`、`conf_test_tpl.yaml`：Strategy YAML 结构改成 method->default->[processors]。
- [`tpl/kitex/server/standard/strategy_init_tpl.yaml`](tpl/kitex/server/standard/strategy_init_tpl.yaml)：用 conf 编译策略并注册；不再空导入、不再 SetActive。
- [`tpl/kitex/server/standard/main_tpl.yaml`](tpl/kitex/server/standard/main_tpl.yaml)：保留启动前 `initStrategies()` 调用。
- [`tpl/kitex/server/standard/strategy.yaml`](tpl/kitex/server/standard/strategy.yaml)：将其角色调整为“示例/占位”，不再通过代码注册 handler（避免与 conf 驱动重复）。

## 数据流（概览）

```mermaid
flowchart TD
  confYaml[conf.yaml] --> confGo[conf.GetConf()]
  userProc[userProcessorsRegister()] --> procReg[MethodProcessors]
  confGo --> init[initStrategies()]
  procReg --> init
  init --> stratReg[MethodStrategies]
  request[Request] --> choose[ChooseMethodStrategy]
  choose --> stratReg
  stratReg --> handler[CompiledHandler]
  handler --> state[MethodState]
  state --> procReg
```

## 风险与边界

- 先实现**线性 pipeline**；不做分支/并行/回滚。
- 需要把策略执行的错误信息做得可读（methodKey、strategyName、缺失的 processorName、可用列表）。